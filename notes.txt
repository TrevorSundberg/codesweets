This is a node system with inputs and outputs
The nodes are heterogenous

The outputs can be whole nodes themselves

Walk the root of the graph and call process
 - A node may generically process its children (in order)
 - Or it may choose the process order manually

The node inputs need to be declared as an object with parameter names

I suppose outputs should be too

What is it that I truly want?

I want users to be able to write components that can plug together
 - All written by different users

As well as customized flows are curated

A user can walk through by starting at the root node and add things to it

Rather than being a crazy graph where we can connect everything, what about just a blackboard and a stack
 - Simplify the crap out of it

We still have dependencies, but the UI might be considerably simplified
 - Means we can't really output single values, only components
 - Might be way easier though than configuring a stupid graph
 - Yes, we are doing this

We might want optional dependencies that display recommended / warnings if it is not there
 - Like, techinically you can install this but it's not recommended unless you have this
 - This mostly influences UX

Another type of component, JsonPatch
 - Takes a file

An example of a custom component, NodeInit which outputs NodePackageJson : SpecificFile
 - Inputs author, keywords, license, etc.
 - Optional dependency on repository so it can get the repo url
 - Creates the package.json file

 - Create a component from multiple components (maybe we just do this in code, but we make it so code can easily use components) YEP

Eslint component
 - Dependence on NodeInit
 - Setup the .eslintrc.json with all inputs (maybe with an 'advanced' category)
 - It's a composition itself that contains a NodeAddDependency with eslint

 - We should make a user selectable component, UserSelection
   - Basically only used when we're making templates
   - We declare what it must produce, for example a FileSystem or GitRepository
   - We put a title and description on it
   - It provides a dropdown to the user that is effectively bottom up
     - Enumerate all things that produce a FileSystem
     - If you click add, it will add it and all dependencies
     - For example, GitHubCreateRepository will add GitHubAuthorization

GitHubAuthorization
GitHubCreateRepository
File
 - Create [Append, Prepend, Ovewrite, ReplaceSubstring]
 - Path: index.js
 - Content: console.log('hello world')

ScriptBash
ScriptNodeJs

Enable/disable components (saves the values but allows users to enable them)
 - Must also disable dependencies

Architecturally, we spin up an image that we maintain on DockerHub
 - Many different useful utilities installed, much like a build server
 - All scripts run on a container and the container has a timeout limit

Hovering over the component shows a description as well as what it produces

ComposableFile
 - Utility class with a bunch of helpers
 - Contains sections that are sorted by priority?
 - Replace, etc functionality
 - ReadMe is a ComposableFile
 - Insertion points? Maybe these points are components themselves

CmakeInit
 - Optional dependency on ReadMe
 - Creates the CMakeLists.txt
 - Adds build instructions automagically into ReadMe
   - Should add an insertion point for cmake command line

VcPkg
 - Optional dependency on cmake?
 - Modifies build instructions to include CMAKE_TOOLCHAIN_FILE=...
